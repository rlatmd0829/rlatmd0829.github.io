---
title: MSA 환경에서의 분산트랜잭션 관리하기위한 패턴들
date: 2023-01-26 12:00:00 +09:00
categories: [MSA, Transaction]
tags: [MSA, Transaction]     
---

## **서론**

마이크로서비스 아키텍처(MSA)는 독립적인 서비스로 분할하여 개발과 관리의 복잡성을 줄여주는 동시에 더 나은 확장성과 장애 격리를 가능하는 장점이 있습니다.
그러나 이러한 장점에도 불구하고, MSA는 분산 시스템에서 발생하는 복잡한 트랜잭션과 데이터 일관성 문제를 해결해야 합니다.

그래서, **MSA 환경에서 분산 트랜잭션을 해결하기 위한 패턴**을 알아보겠습니다.



## **MSA 에서 분산트랜잭션 문제들을 해결하기 위해 사용되는 패턴들**



마이크로서비스 아키텍처에서 사용되는 이러한 패턴들은 각각 다른 문제를 해결하기 위해 설계되었습니다. 각 패턴의 간단한 개념들을 소개하겠습니다.

### **1. Event Sourcing 패턴**

- Event Sourcing은 시스템의 상태 변경을 이벤트 시퀀스로 저장합니다. 모든 변경 사항은 이벤트로 기록되며, 이러한 이벤트 로그를 사용하여 재시도를 통해 데이터 일관성을 맞춥니다.


- 모든 이벤트가 처리되는 시점에 시스템의 상태는 일관된 최종 상태에 도달합니다. 이 과정에서 시간 지연이 발생할 수 있기 때문에, Event Sourcing은 **최종적 일관성**을 제공한다고 말합니다.


- Event Sourcing은 비동기적이고 재시도 메커니즘을 활용하는 경우에 적합하며, 실시간 처리보다는 이벤트의 정확한 기록과 재현에 중점을 둡니다.


### **2. Saga 패턴**

- 여러 마이크로서비스에 걸쳐 있는 긴 비즈니스 프로세스를 일련의 로컬 트랜잭션으로 나눕니다. 각 단계는 독립적으로 실행되며, 실패 시 보상 트랜잭션을 통해 일관성을 유지합니다.


- Saga 패턴은 하나의 서비스에서 실패할 경우, 이전에 성공한 서비스들에서 **보상 트랜잭션**을 수행하여 일관성을 유지합니다.


- Saga 패턴은 실시간 또는 거의 실시간 처리가 필요한 분산 트랜잭션 환경에서 적합하며, 각 단계별 일관성이 중요할 때 사용됩니다.


### **3. CQRS (Command Query Responsibility Segregation) 패턴**

- CQRS는 시스템 내에서 명령(데이터 변경)과 쿼리(데이터 조회)를 분리합니다. 이는 시스템을 더 유연하게 만들고, 성능 최적화와 보안을 향상시킵니다.


- 읽기와 쓰기 작업의 요구 사항이 크게 다른 시스템에서 성능을 최적화하고, **복잡한 쿼리 작업을 용이하게 하기 위해 사용**됩니다.


### **4. Transaction Outbox 패턴**

- Transaction Outbox 패턴은 데이터베이스 트랜잭션과 이벤트 메시징을 안정적으로 통합하기 위한 방법입니다. 로컬 **데이터베이스 트랜잭션과 함께 이벤트를 '아웃박스'** 테이블에 저장하고, 이를 별도의 프로세스가 메시지 브로커로 전송합니다.


- 이벤트 기반 시스템에서 데이터 일관성을 유지하면서 이벤트를 신뢰성 있게 발행하기 위해 사용됩니다. 이는 중요한 메시지가 유실되지 않고 신뢰성 있게 처리될 필요가 있을 때 적합합니다.

> **만약 시스템이 메시지의 일부 유실을 허용하고, 최종적으로 데이터의 일관성만 유지될 수 있다면 Transactional Outbox 패턴을 사용하지 않을 수 있습니다.**


### **5. Materialized View 패턴**

- Materialized View 패턴은 여러 서비스에서 관리되는 데이터를 하나의 조회 가능한 뷰로 통합합니다. 이는 일관된 데이터 뷰를 제공하고, 성능을 최적화합니다.


- 여러 데이터 소스 간의 데이터를 통합하여 사용자에게 일관된 정보를 제공하고, 데이터 액세스의 성능을 향상시키기 위해 사용됩니다.




## **많이 사용되는 조합**

마이크로서비스 아키텍처에서 여러 패턴을 조합해 사용하는 것은 상당히 일반적이며, 각각의 패턴이 서로 다른 문제를 해결하기 때문에 서로 보완적인 관계를 가질 수 있습니다.

### **Event Sourcing과 CQRS**

- Event Sourcing은 모든 변경 사항을 이벤트로 기록하고, CQRS는 이러한 이벤트를 바탕으로 분리된 쿼리 모델을 유지합니다.


- CQRS는 Event Sourcing에서 생성된 이벤트를 사용하여 읽기 모델을 구축하고 업데이트하는 데 유용합니다.

> <font color='dodgerblue'>*Event Sourcing과 CQRS 가 서로의 단점을 보완해주기 때문에 같이 사용하는 경우가 많습니다.*</font>

### **Saga와 Event Sourcing**

- Saga 패턴은 분산 트랜잭션의 일관성을 관리하고, Event Sourcing은 이러한 트랜잭션에서 발생하는 모든 변경을 이벤트로 기록합니다. Saga에서 발생하는 각 단계는 Event Sourcing을 통해 추적될 수 있습니다.


- 복잡한 비즈니스 트랜잭션을 처리하고, 그 과정에서의 각 단계를 명확하게 기록하고 싶을 때 유용합니다.

> <font color='dodgerblue'>보통은 event sourcing으로 이벤트를 기록하여 재시도로 해결하고 트랜잭션을 롤백해야할 경우가 있을경우에 saga패턴을 사용합니다. (결제, 재고 등 이벤트를 기록하여 재시도로는 해결못하고 롤백이 필요한 경우)</font>


### Transaction Outbox와 Event Sourcing

- Transaction Outbox는 Event Sourcing에서 생성된 이벤트를 안정적으로 메시지 브로커로 전송하는 데 사용될 수 있습니다.


- 이벤트 기반 시스템에서 데이터의 일관성을 보장하면서 메시지 전달의 신뢰성을 높이고자 할 때 적합합니다.

> <font color='dodgerblue'>**중요한 메시지가 유실되지 않고 신뢰성 있게 처리될 필요가 있을 때 적합합니다**</font>

### **Materialized View와 CQRS**

- CQRS에서 생성된 데이터 뷰는 Materialized View 패턴을 사용하여 더 효율적으로 캐싱하고 관리할 수 있습니다. Materialized View는 CQRS의 쿼리 모델에 대한 고성능 접근 방식을 제공합니다.


- **고성능 읽기 작업**과 복잡한 쿼리 요구가 있는 시스템, 특히 다양한 서비스로부터 데이터를 통합해야 할 때 유용합니다.



